/******************************************************************************
********************************************************************************
****	Copyright (c) 1997, 1998, 1999
****	Conexant Systems Inc. (formerly Rockwell Semiconductor Systems)
****	Personal Computing Division
****	All Rights Reserved
****
****	CONFIDENTIAL and PROPRIETARY --
****		No Dissemination or use without prior written permission.
****
*******************************************************************************
**
**	MODULE NAME:
**		ChipAL
**
**	FILE NAME:
**		ChipALBusCtlP46.h
**
**	ABSTRACT:
**		Basic 2 Bus Control service public Header file. 
**		This is a component of the  ChipAL module.
**
**	DETAILS:
**		
**
*******************************************************************************
** KEYWORDS:
**	$Archive: /Projects/Tigris and Derivatives/Reference Designs/Tigris/Linux/Kernel Driver/ChipALBusCtlP46.h $
**	$Revision: 1 $
**	$Date: 1/09/01 10:53a $
*******************************************************************************
******************************************************************************/
#ifndef _CHIPALBUSCTLP46_H_				//	File Wrapper,
#define _CHIPALBUSCTLP46_H_				//	prevents multiple inclusions


/*******************************************************************************
Macro Defines
*******************************************************************************/
// Calculate the byte offset of a field in a structure of type type.
//

/*******************************************************************************
Data Type Definitions
*******************************************************************************/

//* The Soft Event Flags are Mutually Exclusive
#if PROJECTS_NAME == PROJECT_NAME_TIGRIS
	#define SOFT_EVENT_SET_1 0
	#define SOFT_EVENT_SET_2 1
	#define SOFT_EVENT_SET_3 0
#elif PROJECTS_NAME == PROJECT_NAME_MADMAX
	#define SOFT_EVENT_SET_1 1
	#define SOFT_EVENT_SET_2 0
	#define SOFT_EVENT_SET_3 0
#elif PROJECTS_NAME == 	PROJECT_NAME_WDM_FILTER
	#define SOFT_EVENT_SET_1 1
	#define SOFT_EVENT_SET_2 0
	#define SOFT_EVENT_SET_3 0

#else
	#define SOFT_EVENT_SET_1 0
	#define SOFT_EVENT_SET_2 0
	#define SOFT_EVENT_SET_3 0
#endif


typedef struct CONFIG_BUS_GET_S
{
	OUT PVOID		BAR0;				// Virtual Address BAR 0
	OUT PVOID		BAR1;				// Virtual Address BAR 1
	OUT USHORT		VendorId;			// Pci Config Space 0x00
	OUT USHORT		DeviceId;			// Pci Config Space 0x02
	OUT USHORT		SubVendorId;		// Pci Config Space 0x2c
	OUT USHORT		SubSystemId;		// Pci Config Space 0x2e
} CONFIG_BUS_GET_T;

typedef union DEV_RESPONSE_U
{
	DWORD			DevResponse;

	struct
	{
DWORD			Function		: 4;
DWORD			Group			: 4 ;
DWORD			Set				: 4 ;
DWORD			Indication		: 4;
DWORD			Reserved		: 16;
	} Code;

} DEV_RESPONSE_T;

//*
//* PciFn function types
//*
#define	BOOT_LOADER					0x00
#define	FUNCTION_0					0x01
#define	FUNCTION_1					0x02
#define	FUNCTION_2					0x03

// *
// * Device Address Ranges
// *
#define ARM_CSR_SIZE 	64
#define ADSL_CSR_SIZE	128
#define ADSL_FUNC_SIZE	4096

//*
//* ARM_RESP_BITS indicates the bits that are actually
//* written by the arm (positive mask).
//*
#define ARM_RESP_BITS					0x0000ffff
#define NUM_ARM_RESP_BITS				16

//*
//* Events generated by Hardware.  These are used to Enable or Disable Interrupts
//* These are normally ChipAl Modular events.  They are used by the
//* vector table functions ...->BusControl->Enable function,
//* (i.e., CalBusCtlP46EnableInterrupt, ...Disable...), etc...
//*
typedef enum _INTERRUPT_EVENT
{
    INT_CMDE		=					0x00000001,
    INT_DATAF		=					0x00000002,
    INT_DEVREADY	=					0x00000004,
    INT_DLREADY	=						0x00000008,
    INT_DLERROR	=						0x00000010,
    INT_GERR	=						0x00000020,
    INT_ARMIRQ0	=						0x00000040,
    INT_ARMIRQ1	=						0x00000080,
    INT_ARMIRQ2	=						0x00000100,
    INT_ARMIRQ3	=						0x00000200,
    INT_ARMIRQ4	=						0x00000400,
    INT_ARMIRQ5=						0x00000800,
    INT_ARMIRQ6	=						0x00001000,
    INT_MARBTIRQ =						0x00002000,
    INT_TIMER0	=						0x00004000,
    INT_TIMER1=							0x00008000,
    INT_GPIO_INT	=					0x00010000,

    INT_DSLIRQ0	=						0x00000004,
    INT_DSLIRQ1	=						0x00000008,
    INT_DSLIRQ2	=						0x00000010,
    INT_DSLIRQ3	=						0x00000020,
    INT_DSLIRQ4	=						0x00000040,
    INT_DSLIRQ5	=						0x00000080,
    INT_DSLIRQ6	=						0x00000100,
    INT_DSLMABRTIRQ	=					0x00000200,
    INT_TX_COUNT	=					0x00000400,
    INT_TX_UNDERRUN=					0x00000800,
    INT_RX_COUNT	=					0x00001000,
    INT_RX_OVERRUN	=					0x00002000,
    INT_IDLE_CNTOV	=					0x00004000,
    INT_DISCARD_CNTOV=					0x00008000,
    INT_DSL_TIMER_0		=				0x00010000,
    INT_DSL_TIMER_1		=				0x00020000,
    INT_FAL_IRQ_1	=					0x00040000,
    INT_FAL_IRQ_2	=					0x00080000,
    INT_GPIO		=					0x00100000,
    INT_AFE			=					0x00200000,
    INT_INVALID		=					0xffffffff

} INTERRUPT_EVENT_T;

//*
//* Events that can be trapped by any driver module(ChipALAddEventHandler, ...)
//*
//* Note: To add a new softevent (non hardware interrupt based), find the
//* correct offset after the HW_BEGIN_SOFT identifier. For ARM commands,
//* you must know the CommandSet, Command Type and Command groups.  There
//* is a section for each in this enumeration.  The ARM response code is as follows:
//*
//* 	ttttssssggggxxxx -
//*			tttt - Indication Type
//*			ssss - Command Set
//*			gggg - Group
//*			xxxx - Function within the Group
//*
//* In the enumeration, the starting point of each group is placed in the
//* gResponseLookup table.  If you are adding to an existing group, there
//* is nothing else to do.  If you create a new Command Set, Command Type
//* or Group, you must place the starting point of the enumeration in the
//* gResponseLookup table.
//* All Max values are based on the enumeration. HW_EVENT_END and
//* HW_MAX_EVENTS both identify the max number of events.  We use two
//* identifiers for legacy purposes.
//*
typedef enum _CHIPAL_EVENT
{
    HW_EVENT_BEGIN =0x00000000,			// Start of Legal Events
    HW_CMDE	= HW_EVENT_BEGIN,			// 0x00000000
    HW_EDATAF,							// 0x00000001

    HW_DVREADY,							// 0x00000002  Different Functions define this bit in differnt ways
    HW_ARMIRQ0 = HW_DVREADY,			// 0x00000002

    HW_ARMIRQ1,							// 0x00000003
    HW_ARMIRQ2,							// 0x00000004
    HW_ARMIRQ3,							// 0x00000005
    HW_ARMIRQ4,							// 0x00000006
    HW_ARMIRQ5,							// 0x00000007
    HW_ARMIRQ6,							// 0x00000008
    HW_MABRTIRQ,						// 0x00000009
    HW_TX_COUNT,						// 0x0000000a
    HW_TX_UNDERRUN,						// 0x0000000b
    HW_RX_COUNT,						// 0x0000000c
    HW_RX_OVERRUN,						// 0x0000000d
    HW_IDLE_CNTOV,						// 0x0000000e
    HW_DISCARD_CNTOV,					// 0x0000000f
    HW_GENERAL_TIMER_A,					// 0x000000010 TIMER0
    HW_GENERAL_TIMER_B,					// 0x000000011 TIMER1
    HW_FAL_IRQ_1 ,						// 0x000000012
    HW_FAL_IRQ_2,						// 0x000000013
    HW_GPIO_INT,						// 0x000000014
    HW_AFE_INT,							// 0x000000015

    HW_BEGIN_SOFT = BITS_PER_EVENT_REG,	// Assumes only one Hardware Event Register

    // Firmware Normal IO Start
    FNIOSTA = HW_BEGIN_SOFT,
    HW_SET_IO_DIRECTION = FNIOSTA,		// 0X00000020
    HW_SET_IO_EDGE,						// 0X00000021
    HW_SET_IO_ACCESS_PRIVILEGE,			// 0X00000022
    HW_SET_IO,							// 0X00000023
    HW_READ_IO,							// 0X00000024
    HW_SET_IO_CHANGE_IND,				// 0X00000025

    // Firmware Normal Timer Start
    FNTMSTA,
    HW_START_PHYSICAL_TIMER = FNTMSTA,	// 0X000000
    HW_STOP_PHYSICAL_TIMER,				// 0X000000
    HW_READ_PHYSICAL_TIMER,				// 0X000000

    HW_TIMER_GAP = FNTMSTA + 7,  // NOTE: Gap in Enumeration May need to adjust
    // if the number of PHYSICAL Timers Change

    HW_START_LOGICAL_TIMER,				// 0X00000023
    HW_STOP_LOGICAL_TIMER,				// 0X00000024
    HW_READ_LOGICAL_TIMER,				// 0X00000025

    // Firmware Normal DMA Start
    FNDMSTA,
    HW_START_TX_DMA = FNDMSTA,			// 0X00000028
    HW_START_RX_DMA,					// 0x00000029
    HW_STOP_DMA,						// 0X0000002A

    // Firmware Normal Configuration Start
    FNCFSTA,
    HW_SET_ADSL_MODE = FNCFSTA,			// 0X00000026

    HW_CONFIG_GAP = FNCFSTA + 14, // NOTE: Config Gap  Adjust if above config commands change.

    HW_CONFIGURATION_COMPLETE,			// 0X000000

    // Firmware Normal Power Management Start
    FNPMSTA,
    HW_POWER_MGMT_EVENT = FNPMSTA,		// 0X000000

    // Firmware Normal Falcon Start
    FNFLSTA,
    HW_QUEUE_FALCON_RX_CMD = FNFLSTA,
    HW_QUEUE_FALCON_TX_CMD,
    HW_CLEAR_FALCON_CMD_QUEUES,

    // Firmware Normal Diag Start
    FNDISTA,
    HW_GET_ERROR_INFO = FNDISTA,
    HW_READ_COUNTER,
    HW_RESET_COUNTER,

    // Firmware Normal Misc Start
    FNMISTA,
    HW_COMMAND_SYNC = FNMISTA,



    // Begin Firmare Special Commands
    // Firmware Special DMA Start
    FSDMSTA,
    HW_ARM_TX_QUEUE_FULL = FSDMSTA,		 // 0X0000003e
    HW_ARM_RX_QUEUE_FULL, 				// 0X0000003f

    // Firmware Special Diag Start
    FSDISTA,
    FSDISTA_GAP	 = 	FSDISTA + 14,			// NOTE GAP
    HW_ARM_COMMAND_PROCESSING_ERROR,


    // Begin Firmware Unsolicited Commands
    // Firmware Unsolicited IO Start
    FUIOSTA,
    FUIOSTA_GAP = FUIOSTA + 4,				// NOTE GAP
    HW_IO_CHANGE_IND,

    // Firmware Unsolicited Timer Start
    FUTMSTA,
    FUTMSTA_GAP = FUTMSTA + 7,			// NOTE GAP
    HW_LOGICAL_TIMER_EXPIRY,
    HW_TIMER_0,							// These are not real events but are used
    HW_TIMER_1,							// to decode an event based on the real event
    // HW_LOGICAL_TIMER_EXPIRY.  This needs to be
    // Moved to the bottom of the enumeration.


    // Firmware Unsolicited DMA Start
    FUDMSTA,
    HW_TX_DMA_COMPLETE = FUDMSTA,		// 0x00000039
    HW_RX_DMA_COMPLETE,					// 0x0000003A

    // Firmware Unsolicited Power Management Start
    FUPMSTA,
    HW_POWER_MGMT_EVENT_UNSOL = FUPMSTA,


    // Firmware Unsolicited Falcon Start
    FUFLSTA,
    HW_FALCON_RX_IND = FUFLSTA,
    HW_FALCON_TX_IND,
    HW_AFE_INDICATION,

    // Firmware Unsolicited Diag Start
    FUDISTA,
    HW_ERROR_IND = FUDISTA,
    HW_COUNTER_OVERFLOW_IND,

    // Firmware Unsolicited Misc Start
    FUMISTA,
    HW_INTERFACE_READY,	   // NOTE GAP

    // BootLoader Normal IO Start
    BNIOSTA,
    HW_BOOT_GET_VERSION,
    HW_BOOT_READ_MEMORY,
    HW_BOOT_SET_MEMORY,
    HW_BOOT_WRITE_MEMORY,
    HW_BOOT_CALL,
    HW_BOOT_GOTO,
    HW_BOOT_GET_EXCEPTION_TABLE,
    HW_BOOT_GET_RAM_DOWNLOAD,
    HW_BOOT_SET_COMMAND_EXTENSION,
    HW_BOOT_SET_IDLE_EXTENSION,

    // BootLoader Normal Power Management Start
    BNPMSTA,
    HW_BOOT_INIT_IN_PROG,
    HW_BOOT_INIT_COMPLETE,
    HW_BOOT_INIT_RAM_ERROR,
    HW_BOOT_INIT_COMPLETE_ERROR,
    HW_BOOT_COMMAND_PROCESSING_ERROR,

    //* Additional Soft Commands,
    HW_GPIO_CHANGE_START,				// 0x00000040
    HW_GPIO_CHANGE_0 = HW_GPIO_CHANGE_START,// 0x00000040 *
    HW_GPIO_CHANGE_1,					// 0x00000041
    HW_GPIO_CHANGE_2,					// 0x00000042
    HW_GPIO_CHANGE_3,					// 0x00000043
    HW_GPIO_CHANGE_4,					// 0x00000044
    HW_GPIO_CHANGE_5,					// 0x00000045
    HW_GPIO_CHANGE_6,					// 0x00000046
    HW_GPIO_CHANGE_7,					// 0x00000047
    HW_GPIO_CHANGE_8,					// 0x00000048
    HW_GPIO_CHANGE_9,					// 0x00000049
    HW_GPIO_CHANGE_10,					// 0x0000004a
    HW_GPIO_CHANGE_11,					// 0x0000004b
    HW_GPIN_CHANGE_12,					// 0x0000004c
    HW_GPIN_CHANGE_13,					// 0x0000004d

    HW_MAX_EVENTS						// This MUST BE LAST in the Enumeration

} CHIPAL_EVENT_T;

#define HW_EVENT_END	HW_MAX_EVENTS


#define MAX_COMMAND_SETS	2
#define MAX_COMMAND_TYPES	3
#define	MAX_COMMAND_GROUPS	16

//*
//* gResponseLookup Translates Arm Response Codes to a set of Linear Mapped responses.  Each entry
//* in this table specificies a starting point for a set of codes in the linear enumeration. It
//* is added to the last byte from the response register to create the real response code.
//*
//* The naming convention for identifers is - STXXSTA
//*	S - Command Set (B - boot Loader, F - Firmware)
//* T - Type (N - Normal, S - Special, U - Unsolicited)
//* STA - Identifier to add a unique element to all starting points (For Searching)
//*
#if defined(_CHIPAL_BUSCTL_C_) || defined(CHIPALBUSCTLP46_C)
SHORT	gResponseLookup[MAX_COMMAND_SETS][MAX_COMMAND_TYPES][MAX_COMMAND_GROUPS] =

    /* Boot Loader (Respose Code Enumeration Start Values)*/
    {
        /*I/O		-	Timer	-	DMA		-	CFG		-		PM		- 	FAL		-		DIA		-		MIS		-  */
        {
            {BNIOSTA,	-1,	-1,		-1,	-1,		-1,	-1,		-1,		BNPMSTA,-1,	-1,		-1,		-1,		-1,		-1,		-1},
            {-1,		-1,	-1,		-1,	-1,		-1,	-1,		-1,		-1,		-1,	-1,		-1,		-1,		-1,		-1,		-1},
            {-1,		-1,	-1,		-1,	-1,		-1,	-1,		-1,		-1,		-1,	-1,		-1,		-1,		-1,		-1,		-1},
        },

/* Firmware (Respose Code Enumeration Start Values) */
{
    /*I/O		-	Timer	-	DMA		-	CFG		-		PM		- 	FAL		-		DIA		-		MIS		-  */
    {FNIOSTA,	-1,	FNTMSTA,-1,	FNDMSTA,-1,	FNCFSTA,-1,		FNPMSTA,-1,	FNFLSTA,-1,		FNDISTA,-1,		FNMISTA,-1},
    {FUIOSTA,	-1,	FUTMSTA,-1,	FUDMSTA,-1,	-1,		-1,		FUPMSTA,-1,	FUFLSTA,-1,		FUDISTA,-1,		FUMISTA,-1},
    {-1,		-1,	-1,		-1,	FSDMSTA,-1,	-1,		-1,		-1,		-1,	-1,		-1,		FSDISTA,-1		-1,		-1},
}
    };
#else
extern SHORT gResponseLookup[MAX_COMMAND_SETS][MAX_COMMAND_TYPES][MAX_COMMAND_GROUPS];

#endif // _CHIPAL_BUSCTL_C_

//*
//* Commands that can be written to the ARM
//*
#define ARM_RESPONSE_TX_DMA_COMPLETE		0x9209
#define ARM_RESPONSE_RX_DMA_COMPLETE		0x920A
#define DSL_LOGICAL_TIMER_EXPIRY			0x920B	// Unsolicited respone to indicate to the host
// CPU that the specified DSL virtual timer has expired
#define START_IND	0x00000008

//* Lookup Starting address of event group then add to function code as an offset;
#define HASH_SOFT_HW_EVENT(Results,Event)	\
Results = gResponseLookup[Event.Code.Set][Event.Code.Indication - START_IND][Event.Code.Group] \
			+ Event.Code.Function 

#define IS_BOOT_LOADER_CSR(Command) ((Command.Code.Set == BOOT_LOADER)? 1 : 0)

//*
//* Register Definitions
//*
typedef union ARM_CTRL_U
{
	DWORD	Value;

	struct //BIT_MAP
	{
DWORD	Sreset		: 1;
DWORD	Tim0_Mux	: 2;
DWORD	Tim1_Mux	: 2;
DWORD	Aie			: 1;
DWORD	FirmGo		: 1;
DWORD	FifoDebug	: 1;
DWORD	Reserved1	: 5;
DWORD	Dis0_D3Rst	: 1;
DWORD	Dis1_D3Rst	: 1;
DWORD	Dis2_D3Rst	: 1;
DWORD	Reserved2	: 16;
	};
} ARM_CTRL_S;

typedef union DSL_CTRL_U
{
	DWORD	Value;

	struct //BIT_MAP_DSL_IER
	{
DWORD	Sreset		: 1;
DWORD	Idle_Insert	: 1;
DWORD	Stream		: 1;
DWORD	Aie			: 1;

DWORD	AfeMux		: 1;
DWORD	TxFifoMux	: 1;
DWORD	RxFifoMux	: 1;
DWORD	IdleClrd	: 1;

DWORD	OvrnClrd	: 1;
DWORD	TestCount	: 1;
DWORD	DmaHeader	: 1;
DWORD	Dis_Txsoc0	: 1;

DWORD	Dsl_Lpbk	: 1;
DWORD	TxByteSwp	: 1;
DWORD	RxByteSwap	: 1;
DWORD	Reserved	: 1;

DWORD	TxUbyte		: 8;

DWORD	Unused		: 8;
	};
} DSL_CTRL_S;


#endif // _CHIPALBUSCTLP46_H File Wrapper,
